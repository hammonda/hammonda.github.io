<!DOCTYPE html>
<html>
<head>
  <title>WebGL 2D Image</title>
</head>
<body>
  <div class="container">
    <canvas id="canvas" width="100" height="100"></canvas>
  </div>
  <style>
    canvas {
      zoom: 400%;
    }
    .container {
      background-color: black;
      display: grid;
      place-items: center;
      height: 100vh; /* Full viewport height */
    }
  </style>
  <script>
    // Get canvas and WebGL context
    const canvas = document.getElementById("canvas");
    const gl = canvas.getContext("webgl");

    // Shader source code
    const vertexShaderSrc = `
      attribute vec2 position;
      void main() {
        gl_Position = vec4(position, 0.0, 1.0);
      }
    `;

    const N = 10;
    const M = 8;
    const X_MID = (canvas.width / 2).toFixed(1);
    const Y_MID = (canvas.height / 2).toFixed(1);

    const fragmentShaderSrc = `
      precision highp float;

      uniform float k;
      uniform float z;
      uniform float pixel_size; 
      uniform float slit_delta;
      uniform float pitch;

      vec2 rotate(vec2 v, float theta) {
        float cos_theta = cos(theta);
        float sin_theta = sin(theta);
        return vec2(v.x*cos_theta - v.y*sin_theta, 
                    v.x*sin_theta + v.y*cos_theta);
      }

      float mag(vec2 v) {
        return v.x*v.x + v.y*v.y;
      }

      vec2 slit(vec2 p_img, vec2 p_slit) {
        // 2d vector from centre of the slit to position in the image.
        vec2 p_d_img = p_img - p_slit;
        float mag_p_d_img = mag(p_d_img);
        float k_over_z = k / z;

        vec2 e = vec2(0.0, 0.0);
        for (int col = -${N}; col <= ${N}; ++col) {
          // The position on the slit relative to p_slit (the centre of the slit).
          vec2 p = vec2(float(col) * slit_delta, 0.0);
          for (int row = -${N}; row <= ${N}; ++row) {
            p.y = float(row) * slit_delta;
            float phase = -k_over_z * dot(p, p_d_img);
            e.x += cos(phase);
            e.y += sin(phase);
          }
        }
        e /= sqrt(z*z + mag_p_d_img);
        return rotate(e, k_over_z * mag_p_d_img / 2.0);
      }

      void main() {
        // The image point (in the x-y plane at z-coordinate z).
        vec2 p_img = vec2((gl_FragCoord.x - ${X_MID}) * pixel_size,
                          (gl_FragCoord.y - ${Y_MID}) * pixel_size);

        // The electric field at point p_img.
        vec2 e = vec2(0.0, 0.0);
        for (int col = -${M}; col <= ${M}; ++col) {
          // The center of the slit (in the x-y plane at z-coordinate 0).
          vec2 p_slit = vec2(float(col) * pitch, 0.0);
          for (int row = -${M}; row <= ${M}; ++row) {
            p_slit.y = float(row) * pitch;
            e += slit(p_img, p_slit);
          }
        }

        float e_m = 0.005 * mag(e);
        float over = e_m > 1.0 ? 0.075 * (e_m - 1.0) : 0.0;
        gl_FragColor = vec4(e_m, over, 0.0, 1.0);
      }
    `;

    // Compile shaders and link program
    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vertexShaderSrc);
    gl.compileShader(vertexShader);
    
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      console.log('Vertex shader failed to compile: ' + gl.getShaderInfoLog(vertexShader));
    }

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragmentShaderSrc);
    gl.compileShader(fragmentShader);

    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      console.log('Fragment shader failed to compile: ' + gl.getShaderInfoLog(fragmentShader));
    }

    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.log('Program failed to link: ' + gl.getProgramInfoLog(program));
    }

    // Use the program
    gl.useProgram(program);

    // Create a square to draw the image on
    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      -1.0, -1.0,
      1.0, -1.0,
      -1.0,  1.0,
      1.0,  1.0
    ]), gl.STATIC_DRAW);

    // Link buffer to shader attribute
    var position = gl.getAttribLocation(program, "position");
    gl.enableVertexAttribArray(position);
    gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);

    // Bind CPU to GPU variables
    var gpu_k = gl.getUniformLocation(program, "k");
    var gpu_z = gl.getUniformLocation(program, "z");
    var gpu_pixel_size = gl.getUniformLocation(program, "pixel_size");
    var gpu_slit_delta = gl.getUniformLocation(program, "slit_delta");
    var gpu_pitch = gl.getUniformLocation(program, "pitch");

    var lambda = 1500.0; // nm
    var z = 500.0; // mm
    var pixel_size = 0.018; // mm
    var slit_width = 0.02; // mm
    var slit_delta = slit_width/(2 * N);
    var pitch = 0.3; // mm  
    var frames = 0;
    var num_frames = 10000;

    animate = () => {
      requestAnimationFrame((currentTime) => {
        gl.uniform1f(gpu_k, 2.0 * Math.PI / (lambda * 1E-6));
        gl.uniform1f(gpu_z, z);
        gl.uniform1f(gpu_pixel_size, pixel_size);
        gl.uniform1f(gpu_slit_delta, slit_delta);
        gl.uniform1f(gpu_pitch, pitch);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        //lambda += 1.0;
        //z += 10.0;
        //pixel_size = 1.0 - frames*0.001;
        pitch = 0.3 + frames*0.0002;
        frames++;
        if (frames < num_frames) {
          animate();
        }
      });
    };

    animate();
  </script>
</body>
</html>
