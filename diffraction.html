<!DOCTYPE html>
<html>
<head>
  <title>Diffraction Simulation</title>
</head>
<body>
  <div class="container">
    <table class="labels">
      <tr>
        <td class="label-name">λ (nm)</td>
        <td class="label-value" id="lambda"></td>
      </tr>
      <tr>
        <td class="label-name">z (mm)</td>
        <td class="label-value" id="z"></td>
      </tr>
      <tr>
        <td class="label-name">Slit size (mm)</td>
        <td class="label-value">
          <span id="slit_width" data-decimal="3"></span>×<span id="slit_height" data-decimal="3"></span>
        </td>
      </tr>
      <tr>
        <td class="label-name">Array size</td>
        <td class="label-value">
          <span id="array_width"></span>×<span id="array_height"></span>
        </td>
      </tr>
      <tr>
        <td class="label-name">Array pitch (mm)</td>
        <td class="label-value" id="pitch" data-decimal="3"></td>
      </tr>
      <tr>
        <td class="label-name">Image size (pixels)</td>
        <td class="label-value">
          <span id="canvas_width"></span>×<span id="canvas_height"></span>
        </td>
      </tr>
      <tr>
        <td class="label-name">Pixel size (mm)</td>
        <td class="label-value" id="pixel_size" data-decimal="3"></td>
      </tr>
      <tr>
        <td class="label-name">Frames</td>
        <td class="label-value" id="frames"></td>
      </tr>
      <tr>
        <td class="label-name">U2 (%)</td>
        <td class="label-value" id="u2" data-decimal="2"></td>
      </tr>
    </table>
    <div class="canvas-wrapper">
      <canvas id="canvas" width="100" height="100"></canvas>
      <canvas id="canvas2" width="100" height="100"></canvas>
    </div>
  </div>
  <style>
    canvas {
      zoom: 400%;
      display: inline-block;
      margin-right: 10px;
    }
    .canvas-wrapper {
      display: inline-flex;
      justify-content: center;
    }
    .container {
      background-color: black;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      position: relative;
    }

    .labels {
      position: absolute;
      top: 0;
      left: 0;
      padding-top: 10px;
      padding-left: 10px;
      color: white;
    }
    .label-value {
      padding-left: 10px;
    }
  </style>
  <script>
    function updateLabels(meta) {
      for (const key in meta) {
        const labelElement = document.getElementById(key);
        if (labelElement) {
          const decimalPlacesAttr = labelElement.getAttribute('data-decimal');
          const decimalPlaces = decimalPlacesAttr !== null ? parseInt(decimalPlacesAttr, 10) : 0;
          labelElement.textContent = meta[key].toFixed(decimalPlaces);
        }
      }
    }
  </script>
  <script>
  let storedPixels = [];  // Array to store pixel data
  function updateCanvas2FromCanvas1(gl, ctx2) {
    // Get dimensions from the WebGL canvas
    const canvas1 = gl.canvas;
    const width = canvas1.width;
    const height = canvas1.height;

    // Create a buffer to read pixel data
    const pixels = new Uint8Array(width * height * 4);
    
    // Read pixels from WebGL canvas
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    
    // Add read pixels to the storedPixels array and update maxPixelValue
    let maxPixelValue = 0;
    let minPixelValue = Number.MAX_VALUE;
    for (let i in pixels) {
      storedPixels[i] = (storedPixels[i] || 0) + pixels[i];
      maxPixelValue = Math.max(maxPixelValue, storedPixels[i]);
      minPixelValue = Math.min(minPixelValue, storedPixels[i]);
    }

    // Create a normalized pixel array
    const normalizedPixels = new Uint8ClampedArray(pixels.length);
    for (let i in storedPixels) {
      normalizedPixels[i] = (storedPixels[i] / maxPixelValue) * 255;
    }
    
    // Create new ImageData and update canvas2
    const imgData = new ImageData(normalizedPixels, width, height);
    ctx2.putImageData(imgData, 0, 0);
    return 100.0 * minPixelValue / maxPixelValue;
  }
  </script>
  <script>
    // Get canvas and WebGL context
    const canvas = document.getElementById("canvas");
    const gl = canvas.getContext("webgl");

    // Enable float textures
//    const ext = gl.getExtension("OES_texture_float");
//    if (!ext) {
//      console.log("OES_texture_float is not available");
//    }

    const canvas2 = document.getElementById("canvas2");
    const ctx2 = canvas2.getContext("2d");

    // Shader source code
    const vertexShaderSrc = `
      attribute vec2 position;
      void main() {
        gl_Position = vec4(position, 0.0, 1.0);
      }
    `;

    const N = 20;
    const M = 8;
    const MM = 2*M + 1;
    const X_MID = (canvas.width / 2).toFixed(1);
    const Y_MID = (canvas.height / 2).toFixed(1);

    const fragmentShaderSrc = `
      precision highp float;

      uniform float k;
      uniform float z;
      uniform float pixel_size; 
      uniform float slit_delta;
      uniform float pitch;
      uniform float random_phase[${MM*MM}];

      vec2 rotate(vec2 v, float theta) {
        float cos_theta = cos(theta);
        float sin_theta = sin(theta);
        return vec2(v.x*cos_theta - v.y*sin_theta, 
                    v.x*sin_theta + v.y*cos_theta);
      }

      float mag(vec2 v) {
        return v.x*v.x + v.y*v.y;
      }

      vec2 slit(vec2 p_img, vec2 p_slit, float r_phase) {
        // 2d vector from centre of the slit to position in the image.
        vec2 p_d_img = p_img - p_slit;
        float mag_p_d_img = mag(p_d_img);
        float k_over_z = k / z;

        vec2 e = vec2(0.0, 0.0);
        for (int col = -${N}; col <= ${N}; ++col) {
          // The position on the slit relative to p_slit (the centre of the slit).
          vec2 p = vec2(float(col) * slit_delta, 0.0);
          for (int row = -${N}; row <= ${N}; ++row) {
            p.y = float(row) * slit_delta;
            float phase = -k_over_z * dot(p, p_d_img);
            e.x += cos(phase);
            e.y += sin(phase);
          }
        }
        e /= sqrt(z*z + mag_p_d_img);
        return rotate(e, r_phase + k_over_z * mag_p_d_img / 2.0);
      }

      void main() {
        // The image point (in the x-y plane at z-coordinate z).
        vec2 p_img = vec2((gl_FragCoord.x - ${X_MID}) * pixel_size,
                          (gl_FragCoord.y - ${Y_MID}) * pixel_size);

        // The electric field at point p_img.
        vec2 e = vec2(0.0, 0.0);
        for (int col = 0; col <= ${MM}; ++col) {
          // The center of the slit (in the x-y plane at z-coordinate 0).
          vec2 p_slit = vec2(float(col - ${M}) * pitch, 0.0);
          for (int row = 0; row <= ${MM}; ++row) {
            p_slit.y = float(row - ${M}) * pitch;
            e += slit(p_img, p_slit, random_phase[col*${MM} + row]);
          }
        }

        float e_m = mag(e);
        e_m *= 0.0005;
        float over = e_m > 1.0 ? 0.05 * (e_m - 1.0) : 0.0;
        gl_FragColor = vec4(e_m, over, 0.0, 1.0);
      }
    `;

    // Compile shaders and link program
    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vertexShaderSrc);
    gl.compileShader(vertexShader);
    
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      console.log('Vertex shader failed to compile: ' + gl.getShaderInfoLog(vertexShader));
    }

    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragmentShaderSrc);
    gl.compileShader(fragmentShader);

    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      console.log('Fragment shader failed to compile: ' + gl.getShaderInfoLog(fragmentShader));
    }

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.log('Program failed to link: ' + gl.getProgramInfoLog(program));
    }

    // Use the program
    gl.useProgram(program);

    // Create a square to draw the image on
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      -1.0, -1.0,
      1.0, -1.0,
      -1.0,  1.0,
      1.0,  1.0
    ]), gl.STATIC_DRAW);

    // Link buffer to shader attribute
    const position = gl.getAttribLocation(program, "position");
    gl.enableVertexAttribArray(position);
    gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);

    // Bind CPU to GPU variables
    const gpu_k = gl.getUniformLocation(program, "k");
    const gpu_z = gl.getUniformLocation(program, "z");
    const gpu_pixel_size = gl.getUniformLocation(program, "pixel_size");
    const gpu_slit_delta = gl.getUniformLocation(program, "slit_delta");
    const gpu_pitch = gl.getUniformLocation(program, "pitch");
    const gpu_random_phase = gl.getUniformLocation(program, "random_phase");

    const random_phase = new Float32Array(MM*MM);

    const meta = {};
    meta.lambda = 1500.0; // nm.
    meta.z = 500.0; // mm
    meta.pixel_size = 0.018; // mm
    meta.slit_width = 0.02; // mm
    meta.slit_height = meta.slit_width;
    meta.slit_delta = meta.slit_width/(2 * N);
    meta.pitch = 0.94; // mm
    meta.array_width = 2*M + 1;
    meta.array_height = meta.array_width;
    meta.canvas_width = canvas.width;
    meta.canvas_height = canvas.height;
    meta.frames = 0;
    meta.u2 = 0;

    const num_frames = 5;

    animate = () => {
      requestAnimationFrame((currentTime) => {
        gl.uniform1f(gpu_k, 2.0 * Math.PI / (meta.lambda * 1E-6));
        gl.uniform1f(gpu_z, meta.z);
        gl.uniform1f(gpu_pixel_size, meta.pixel_size);
        gl.uniform1f(gpu_slit_delta, meta.slit_delta);
        gl.uniform1f(gpu_pitch, meta.pitch);
        for (let i in random_phase) {
          random_phase[i] = 2 * Math.PI * Math.random();
        }
        gl.uniform1fv(gpu_random_phase, new Float32Array(random_phase));
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        //meta.u2 = updateCanvas2FromCanvas1(gl, ctx2);
        meta.frames++;
        updateLabels(meta);
        if (meta.frames < num_frames) {
          //meta.pitch = 0.94 + frames*0.0002;
          animate();
        }
      });
    };

    animate();
  </script>
</body>
</html>
